#version 460
#extension GL_NV_ray_tracing : require
#pragma shader_stage(raygen)

#include "../../shaders/camera.glsl"
#include "../../shaders/definition.glsl"
#include "isShadowedDefine.glsl"
#include "light.glsl"
#include "phong_compute.glsl"
#include "shadow_ray.glsl"

layout(location = 0) rayPayloadNV vec3 hitValue;

layout(binding = 0) uniform sampler2D gPositionTexture;
layout(binding = 1) uniform sampler2D gNormalTexture;
layout(binding = 2) uniform sampler2D gDiffuseTexture;
layout(binding = 3) uniform sampler2D gDepthShininessTexture;

layout(set = 1, binding = 0) uniform accelerationStructureNV topLevelAS;
layout(std140, set = 1, binding = 1) buffer PixelBuffer { vec4 pixels[]; }
pixelBuffer;

vec2 getLanuchIndex(uvec3 launchIDNV, uvec3 launchSizeNV) {
  const vec2 pixelCenter = vec2(launchIDNV.xy) + vec2(0.5);
  const vec2 inUV = pixelCenter / vec2(launchSizeNV.xy);

  return inUV * 2.0 - 1.0;
}

float LinearDepth(float depth) {
  return (2.0 * NEAR_Z) / (FAR_Z + NEAR_Z - depth * (FAR_Z - NEAR_Z));
}

bool isNotBackground(vec4 worldPosition) { return worldPosition.w == 0.0; }

void main() {
  vec2 lanuchIndex = getLanuchIndex(gl_LaunchIDNV, gl_LaunchSizeNV);

  vec4 worldPosition = texture(gPositionTexture, lanuchIndex);
  vec3 worldNormal = texture(gNormalTexture, lanuchIndex).rgb;
  vec3 diffuse = texture(gDiffuseTexture, lanuchIndex).rgb;
  // vec3 specular = texture(gSpecularTexture, lanuchIndex).rgb;
  vec3 specular = vec3(0.5, 0.0, 0.5);
  vec4 depthShininess = texture(gDepthShininessTexture, lanuchIndex);
  // float depth = LinearDepth(depthShininess.r);
  float shininess = depthShininess.g;

  TODO why has 4 parts???

  // hitValue = vec3(0.0);
  hitValue = vec3(diffuse);
  // hitValue = vec3(lanuchIndex, 1.0);
  // hitValue = texture(gDiffuseTexture, vec2(0.2,0.6)).rgb;

  // if (isNotBackground(worldPosition)) {
  //   // vec3 lightDir;
  //   // float lightIntensity;
  //   // float lightDistance;

  //   // getLightData(lightIntensity, lightDistance, lightDir);

  //   // // Diffuse
  //   // diffuse = computeDiffuse(diffuse, lightDir, worldNormal);

  //   // // vec3 specular = vec3(0.0);
  //   // float attenuation = 1.0;

  //   // // Tracing shadow ray only if the light is visible from the surface
  //   // if (isLightVisibleFromTheSurface(worldNormal, lightDir)) {
  //   //   float tMin = 0.001;
  //   //   float tMax = lightDistance;
  //   //   // vec3 origin = gl_WorldRayOriginNV + gl_WorldRayDirectionNV * gl_HitTNV;
  //   //   vec3 origin = vec3(worldPosition);
  //   //   vec3 rayDir = lightDir;

  //   //   bool isShadowed =
  //   //       shadowRayVisibility(topLevelAS, 1, origin, rayDir, tMin, tMax);

  //   //   if (isShadowed) {
  //   //     attenuation = 0.3;
  //   //   } else {
  //   //     specular = computeSpecular(specular, shininess,
  //   //                                getViewDir(vec3(worldPosition)), lightDir,
  //   //                                worldNormal);
  //   //   }
  //   // }

  //   // hitValue = computeColor(lightIntensity, attenuation, diffuse, specular);
  //   hitValue=vec3(1.0,0.0,0.0);
  // }

  const uint pixelIndex = gl_LaunchIDNV.y * gl_LaunchSizeNV.x + gl_LaunchIDNV.x;

  pixelBuffer.pixels[pixelIndex] = vec4(hitValue, 1.0);
  // pixelBuffer.pixels[pixelIndex] = vec4(1.0, 0.0, 0.0, 1.0);
}