#version 460
#extension GL_NV_ray_tracing : require
#pragma shader_stage(raygen)

#include "../../shaders/camera.glsl"
#include "light.glsl"
#include "phong_compute.glsl"

layout(location = 0) rayPayloadNV vec3 hitValue;
layout(location = 1) rayPayloadNV bool isShadowed;

#include "shadow_ray.glsl"

layout(binding = 0) uniform sampler2D gPositionTexture;
layout(binding = 1) uniform sampler2D gNormalTexture;
layout(binding = 2) uniform sampler2D gDiffuseTexture;
layout(binding = 3) uniform sampler2D gMotionVectorDepthShininessTexture;

layout(set = 1, binding = 0) uniform accelerationStructureNV topLevelAS;
layout(std140, set = 1, binding = 1) buffer PixelBuffer { vec4 pixels[]; }
pixelBuffer;

vec2 getLanuchIndex(uvec3 launchIDNV, uvec3 launchSizeNV) {
  const vec2 pixelCenter = vec2(launchIDNV.xy) + vec2(0.5);
  const vec2 inUV = pixelCenter / vec2(launchSizeNV.xy);

  // // return inUV * 2.0 - 1.0;
  return inUV;
}

bool isNotBackground(vec4 worldPosition) { return worldPosition.w == 0.0; }

void main() {
  vec2 lanuchIndex = getLanuchIndex(gl_LaunchIDNV, gl_LaunchSizeNV);

  vec4 worldPosition = texture(gPositionTexture, lanuchIndex);
  vec3 worldNormal = texture(gNormalTexture, lanuchIndex).rgb;
  vec3 materialDiffuse = texture(gDiffuseTexture, lanuchIndex).rgb;
  // vec3 materialSpecular = texture(gSpecularTexture, lanuchIndex).rgb;
  vec3 materialSpecular = vec3(0.5, 0.0, 0.5);
  vec4 motionVectorDepthShininess =
      texture(gMotionVectorDepthShininessTexture, lanuchIndex);
  float shininess = motionVectorDepthShininess.w;

  hitValue = vec3(0.0);

  vec3 specular = vec3(0.0);

  if (isNotBackground(worldPosition)) {

    vec3 lightDir;
    float lightIntensity;
    float lightDistance;

    getLightData(lightIntensity, lightDistance, lightDir);

    // Diffuse
    vec3 diffuse = computeDiffuse(materialDiffuse, lightDir, worldNormal);

    float attenuation = 1.0;

    // Tracing shadow ray only if the light is visible from the surface
    if (isLightVisibleFromTheSurface(worldNormal, lightDir)) {
      // float tMin = 0.01;
      float tMin = 0.1;
      float tMax = lightDistance;
      // vec3 origin = gl_WorldRayOriginNV + gl_WorldRayDirectionNV * gl_HitTNV;
      vec3 origin = vec3(worldPosition);
      vec3 rayDir = lightDir;

      isShadowed =
          shadowRayVisibility(topLevelAS, 0, origin, rayDir, tMin, tMax);

      if (isShadowed) {
        attenuation = 0.3;
      } else {
        specular = computeSpecular(materialSpecular, shininess,
                                   getViewDir(vec3(worldPosition)), lightDir,
                                   worldNormal);
      }
    }

    hitValue = computeColor(lightIntensity, attenuation, diffuse, specular);
  }

  const uint pixelIndex = gl_LaunchIDNV.y * gl_LaunchSizeNV.x + gl_LaunchIDNV.x;

  pixelBuffer.pixels[pixelIndex] = vec4(hitValue, 1.0);
}