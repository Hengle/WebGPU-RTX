#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#pragma shader_stage(raygen)

#include "../../shaders/camera.glsl"
#include "common_data.glsl"
#include "define.glsl"
#include "raycommon.glsl"

#include "light.glsl"
#include "phong_compute.glsl"
#include "random.glsl"

#include "indirect_utils.glsl"

layout(location = 1) rayPayloadNV bool isShadowed;

#include "shadow_ray.glsl"

#include "compute_direct_gi.glsl"

layout(location = 0) rayPayloadNV hitPayload prd;

#include "indirect_ray.glsl"

layout(binding = 0) uniform sampler2D gPositionTexture;
layout(binding = 1) uniform sampler2D gNormalTexture;
layout(binding = 2) uniform sampler2D gDiffuseTexture;
layout(binding = 3) uniform sampler2D gMotionVectorDepthShininessTexture;

layout(set = 1, binding = 0) uniform accelerationStructureNV topLevelAS;
layout(std140, set = 1, binding = 1) buffer PixelBuffer { vec4 pixels[]; }
pixelBuffer;

layout(std140, set = 1, binding = 2) uniform CommonData { vec4 compressedData; }
pushC;

vec2 getLanuchIndex(uvec3 launchIDNV, uvec3 launchSizeNV) {
  const vec2 pixelCenter = vec2(launchIDNV.xy) + vec2(0.5);
  const vec2 inUV = pixelCenter / vec2(launchSizeNV.xy);

  // // return inUV * 2.0 - 1.0;
  return inUV;
}

bool isNotBackground(vec4 worldPosition) { return worldPosition.w == 0.0; }

void main() {
  vec4 commonDataCompressedData = pushC.compressedData;
  uint frame = getFrame(commonDataCompressedData);
  uint lightCount = getLightCount(commonDataCompressedData);
  // bool doIndirectGI = getDoIndirectGI(commonDataCompressedData);
  bool doIndirectGI = true;
  // bool doIndirectGI = false;

  float tMin = 0.1;

  uint seed = tea(gl_LaunchIDNV.y * gl_LaunchSizeNV.x + gl_LaunchIDNV.x, frame);

  prd.seed = seed;

  vec2 lanuchIndex = getLanuchIndex(gl_LaunchIDNV, gl_LaunchSizeNV);

  vec4 worldPosition = texture(gPositionTexture, lanuchIndex);
  vec3 worldNormal = texture(gNormalTexture, lanuchIndex).xyz;
  vec3 materialDiffuse = texture(gDiffuseTexture, lanuchIndex).rgb;

  // TODO feat: get specular from material
  // vec3 materialSpecular = texture(gSpecularTexture, lanuchIndex).rgb;
  vec3 materialSpecular = vec3(0.5, 0.0, 0.5);
  // vec3 materialSpecular = vec3(0.0, 0.0, 0.5);

  vec4 motionVectorDepthShininess =
      texture(gMotionVectorDepthShininessTexture, lanuchIndex);
  float shininess = motionVectorDepthShininess.w;

  vec3 hitValue = vec3(0.0);

  if (isNotBackground(worldPosition)) {
    hitValue += computeDirectGI(seed, tMin, lightCount, vec3(worldPosition),
                                worldNormal, materialDiffuse, materialSpecular,
                                shininess, topLevelAS);

    if (doIndirectGI) {
      // Select a random direction for our diffuse interreflection ray.
      vec3 bounceDir;
      bounceDir = getCosHemisphereSample(seed, worldNormal);

      vec3 bounceColor =
          shootIndirectRay(topLevelAS, worldPosition.xyz, bounceDir, tMin);

      // Get dotNL for our selected ray direction
      float dotNL = max(dot(worldNormal, bounceDir), 0.0);

      // Probability of selecting this ray ( cos/pi for cosine sampling, 1/2pi
      // for uniform sampling )
      float sampleProb = (dotNL / M_PI);

      // Do Monte Carlo integration of indirect light (i.e., rendering equation)
      //    -> This is:  (dotNL * incoming light * BRDF) / probability-of-sample
      // hitValue += dotNL * bounceColor * materialDiffuse / sampleProb;
      hitValue += ( dotNL * bounceColor * materialDiffuse / M_PI ) / sampleProb;
    }
  } else {
    // TODO refactor: add miss color to common data buffer?
    hitValue = vec3(0.15);
  }

  const uint pixelIndex = gl_LaunchIDNV.y * gl_LaunchSizeNV.x + gl_LaunchIDNV.x;

  pixelBuffer.pixels[pixelIndex] = vec4(hitValue, 1.0);
}