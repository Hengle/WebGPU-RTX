#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#pragma shader_stage(raygen)

#include "../../shaders/camera.glsl"
#include "../../shaders/common_data.glsl"
#include "define.glsl"
#include "raycommon.glsl"
#include "reduce_noise_data.glsl"
#include "shading_data.glsl"

#include "light.glsl"
#include "pbr_compute.glsl"
#include "random.glsl"

#include "disney.glsl"
#include "disney_utils.glsl"

#include "indirect_utils.glsl"

#include "../../shaders/sample_utils.glsl"

layout(location = 1) rayPayloadNV bool isShadowed;

#include "shadow_ray.glsl"

#include "ggx_direct.glsl"

layout(location = 0) rayPayloadNV hitPayload prd;

#include "indirect_ray.glsl"

const uint indirectLightSpecularSampleCount = 1;

float randomArr[indirectLightSpecularSampleCount];

#include "ggx_indirect.glsl"

layout(binding = 0) uniform sampler2D gPositionRoughnessTexture;
layout(binding = 1) uniform sampler2D gNormalMetalnessTexture;
layout(binding = 2) uniform sampler2D gDiffusePositionWTexture;
layout(binding = 3) uniform sampler2D gMotionVectorDepthSpecularTexture;

layout(set = 1, binding = 0) uniform accelerationStructureNV topLevelAS;
layout(std140, set = 1, binding = 1) buffer PixelBuffer { vec4 pixels[]; }
pixelBuffer;

layout(std140, set = 1, binding = 2) uniform CommonData { vec4 compressedData; }
pushC;

layout(std140, set = 1, binding = 3) uniform ReduceNoiseData {
  vec4 compressedData;
}
reduceNoiseData;

vec2 getLanuchIndex(uvec3 launchIDNV, uvec3 launchSizeNV) {
  const vec2 pixelCenter = vec2(launchIDNV.xy) + vec2(0.5);
  const vec2 inUV = pixelCenter / vec2(launchSizeNV.xy);

  // // return inUV * 2.0 - 1.0;
  return inUV;
}

bool isNotBackground(vec4 worldPosition) { return worldPosition.w == 0.0; }

void main() {
  vec4 commonDataCompressedData = pushC.compressedData;
  uint frame = getFrame(commonDataCompressedData);
  uint lightCount = getLightCount(commonDataCompressedData);
  // bool doIndirectGI = getDoIndirectGI(commonDataCompressedData);
  bool doIndirectGI = true;
  // bool doIndirectGI = false;

  float tMin = 0.1;

  uint seed = tea(gl_LaunchIDNV.y * gl_LaunchSizeNV.x + gl_LaunchIDNV.x, frame);

  prd.seed = seed;

  vec2 lanuchIndex = getLanuchIndex(gl_LaunchIDNV, gl_LaunchSizeNV);

  vec4 positionRoughness = texture(gPositionRoughnessTexture, lanuchIndex);
  vec4 diffusePositionW = texture(gDiffusePositionWTexture, lanuchIndex);
  vec4 normalMetalness = texture(gNormalMetalnessTexture, lanuchIndex);
  vec4 motionVectorDepthSpecular =
      texture(gMotionVectorDepthSpecularTexture, lanuchIndex);

  vec4 worldPosition = vec4(positionRoughness.xyz, diffusePositionW.a);
  vec3 worldNormal = normalMetalness.xyz;
  vec3 materialDiffuse = diffusePositionW.rgb;
  // vec3 materialSpecularColor = vec3(0.5, 0.0, 0.5);
  float materialMetalness = normalMetalness.w;
  float materialRoughness = positionRoughness.w;
  float materialSpecular = motionVectorDepthSpecular.w;

  ShadingData shading = buildShadingData(materialDiffuse, materialMetalness,
                                         materialRoughness, materialSpecular);

  vec3 hitValue = vec3(0.0);

  if (isNotBackground(worldPosition)) {
    vec3 V = computeV(uCamera.cameraPosition.xyz, worldPosition.xyz);

    hitValue += computeDirectLight(seed, 0, tMin, lightCount, worldPosition.xyz,
                                   worldNormal, V, shading, topLevelAS);

    // if(luminance(hitValue) >= maxValue ){

    //         hitValue = vec3(clamp(hitValue.x, 0.0, maxValue),
    //                              clamp(hitValue.y, 0.0, maxValue),
    //                              clamp(hitValue.z, 0.0, maxValue));
    // }

    if (doIndirectGI) {
      vec3 indirectLight = computeIndirectLight(
          seed, tMin, V, worldPosition.xyz, worldNormal, shading, topLevelAS);

      // if(luminance(indirectLight) <= maxValue ){

      //         hitValue += indirectLight;

      // }

      // const vec3 indirectLightClampMaxValue = vec3(18.0);

      // indirectLight =
      //     clamp(indirectLight, vec3(0.0), indirectLightClampMaxValue);

      hitValue += indirectLight;
    }
  } else {
    // TODO refactor: add miss color to common data buffer?
    hitValue = vec3(0.15);
  }

  const uint pixelIndex = gl_LaunchIDNV.y * gl_LaunchSizeNV.x + gl_LaunchIDNV.x;

  pixelBuffer.pixels[pixelIndex] = vec4(hitValue, 1.0);
}